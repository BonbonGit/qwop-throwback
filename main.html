<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>QWOP-Throwback</title>
    <link rel="stylesheet" href="main.css">
    <script type="text/javascript">
      var canvas;
      var ctx;

      class staticGO {
        constructor(width=10, height=10, x=0, y=0) {
          this.type = staticGO;
          this.width = width;
          this.height = height;
          this.x = x;
          this.y = y;
          this.xHitBox = this.width/2
          this.yHitBox = this.height/2
        }
      }
      class GO{
        constructor(width=10, height=10, x=0, y=0, angle=0){
          this.type = GO;
          this.width = width;
          this.height = height;
          this.x = x;
          this.y = y;
          this.angle = angle;
          //The object max width/height (due to angle) define both hitBox limits. We keep (max width/height)² because we compare it to another "²" value during collisions checks
          this.hitBox = Math.sqrt(Math.pow(this.width/2,2)+Math.pow(this.height/2,2));
          console.log(this.hitBox);
          this.xSpeed = 0;
          this.ySpeed = 0;
          this.rotSpeed = 0;
        }
        accelerate(xAcc, yAcc, rotAcc){
          this.xSpeed += xAcc * Game.tSLF;
          this.ySpeed += (yAcc + Game.gravity) * Game.tSLF;
          this.rotSpeed += rotAcc * Game.tSLF;
        }
        updatePos(){
          this.x += this.xSpeed * Game.tSLF;
          this.y += this.ySpeed * Game.tSLF;
          this.angle += this.rotSpeed * Game.tSLF;
        }

      }
      class ColorGO extends GO{
        constructor(width=10, height=10, x=0, y=0, angle=0, color='red'){
          super(width, height, x, y, angle)
          this.color = color;
        }
        render(){
          if(!(this.x > canvas.width+this.hitBox || this.x < -this.hitBox || this.y > canvas.height+this.hitBox || this.y < -this.hitBox)){
            ctx.fillStyle = this.color;

            ctx.save();
              ctx.translate(this.x, this.y);
              ctx.rotate(this.angle);
              ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
            ctx.restore();
          }
        }
      }


      var Game = {

        now: 0,
        then: 0,
        tSLF:0,//time since last frame

        gravity:10, //gravitational acceleration in px/sec
        blueSquare: new ColorGO(20, 20, 200, 750, Math.PI/4, 'blue'),
        greenSquare: new ColorGO(20, 20, 1000, 750, Math.PI/4, 'green'),
        //wall: new ColorGO(40, 600, 600, 400, 0, 'red'),
        update: function(){
          this.contact();
          this.blueSquare.accelerate(0, 0, 0);
          this.blueSquare.updatePos();
          this.greenSquare.accelerate(0, 0, 0);
          this.greenSquare.updatePos();

        },
        render: function(){
          ctx.clearRect(0,0,canvas.width,canvas.height);
          this.blueSquare.render();
          this.greenSquare.render();
          //this.wall.render();
        },
        contact: function(){
          /*if(Math.abs(this.greenSquare.x-this.wall.x) <= (this.greenSquare.width+this.wall.width)/2){
            this.greenSquare.xSpeed = -this.greenSquare.xSpeed
          }
          if(Math.abs(this.blueSquare.x-this.wall.x) <= (this.blueSquare.width+this.wall.width)/2){
            this.blueSquare.xSpeed = -this.blueSquare.xSpeed
          }*/
          this.collision(this.blueSquare, this.greenSquare);

          /*if(Math.abs(this.blueSquare.x-this.greenSquare.x) <= (this.blueSquare.hitBox+this.greenSquare.hitBox)){
            console.log(Math.abs(this.blueSquare.x-this.greenSquare.x));
            this.blueSquare.xSpeed = -this.blueSquare.xSpeed;
            this.greenSquare.xSpeed = -this.greenSquare.xSpeed;
          }*/
        },
        collision: function(a, b){
          let xDist = a.x-b.x;
          let yDist = b.y-a.y;
          let xDistP2 = Math.pow(xDist,2)
          let yDistP2 = Math.pow(yDist,2)

          if(Math.sqrt(xDistP2+yDistP2) <= a.hitBox+b.hitBox){
            console.log(Math.sqrt(xDistP2+yDistP2));
            a.xSpeed = a.xSpeed - ((a.xSpeed-b.xSpeed)*xDist+(a.ySpeed-b.ySpeed)*yDist)/(xDistP2+yDistP2)*xDist
            a.ySpeed = a.ySpeed - ((a.xSpeed-b.xSpeed)*xDist+(a.ySpeed-b.ySpeed)*yDist)/(xDistP2+yDistP2)*yDist
            xDist = -xDist;
            yDist = -yDist;
            b.xSpeed = ((b.xSpeed-a.xSpeed)*xDist+(b.ySpeed-a.ySpeed)*yDist)/(xDistP2+yDistP2)*xDist - b.xSpeed;
            b.ySpeed = b.ySpeed - ((b.xSpeed-a.xSpeed)*xDist+(b.ySpeed-a.ySpeed)*yDist)/(xDistP2+yDistP2)*yDist;
          }
        }
      }
      function init(){
        canvas = document.getElementById('gameArea');
        ctx = canvas.getContext('2d');
        Game.then = performance.now();
        Game.blueSquare.xSpeed = 400;
        Game.blueSquare.ySpeed = -200;
        Game.greenSquare.xSpeed = -400;
        Game.greenSquare.ySpeed = -200;
        main();
      }
      function main() {
        window.requestAnimationFrame(main);
        //time at loop start
        Game.now = performance.now();
        Game.tSLF = (Game.now - Game.then)/1000;

        if(Game.tSLF > 16/1000){ //Aprox 60FPS
          //console.log(1/Game.tSLF);
          Game.update();
          Game.render();
          Game.then = Game.now;
        }
      }

    </script>
  </head>
  <body onload="init()">
    <canvas id="gameArea" height="800" width="1200"></canvas>
  </body>
</html>
