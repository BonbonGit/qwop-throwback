<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>QWOP-Throwback</title>
    <link rel="stylesheet" href="main.css">
    <script type="text/javascript">
      var canvas;
      var ctx;

      class staticGO {
        constructor(width=10, height=10, x=0, y=0) {
          this.type = staticGO;
          this.width = width;
          this.height = height;
          this.x = x;
          this.y = y;
          this.xHitBox = this.width/2
          this.yHitBox = this.height/2
        }
      }
      class GO{
        constructor(width=10, height=10, x=0, y=0, angle=0){
          this.type = GO;
          this.width = width;
          this.height = height;
          this.x = x;
          this.y = y;
          this.angle = angle;
          //The object max width/height (due to angle) define both hitBox limits. We keep (max width/height)² because we compare it to another "²" value during collisions checks
          this.hitBox = Math.pow(this.width/2,2)+Math.pow(this.height/2,2);
          console.log(this.hitBox);
          this.xSpeed = 0;
          this.ySpeed = 0;
          this.rotSpeed = 0;
        }
        accelerate(xAcc, yAcc, rotAcc){
          this.xSpeed += xAcc * Game.tSLF;
          this.ySpeed += (yAcc + Game.gravity) * Game.tSLF;
          this.rotSpeed += rotAcc * Game.tSLF;
        }
        updatePos(){
          this.x += this.xSpeed * Game.tSLF;
          this.y += this.ySpeed * Game.tSLF;
          this.angle += this.rotSpeed * Game.tSLF;
        }

      }
      class ColorGO extends GO{
        constructor(width=10, height=10, x=0, y=0, angle=0, color='red'){
          super(width, height, x, y, angle)
          this.color = color;
        }
        render(){
          ctx.fillStyle = this.color;

          ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
          ctx.restore();

        }
      }


      var Game = {

        now: 0,
        then: 0,
        tSLF:0,//time since last frame

        gravity:10, //gravitational acceleration in px/sec
        blueSquare: new ColorGO(20, 20, 10, 750, Math.PI/4, 'blue'),
        greenSquare: new ColorGO(20, 20, 1190, 750, Math.PI/4, 'green'),
        //wall: new ColorGO(40, 600, 600, 400, 0, 'red'),
        update: function(){
          this.blueSquare.accelerate(0, 0, 0);
          this.blueSquare.updatePos();
          this.greenSquare.accelerate(0, 0, 0);
          this.greenSquare.updatePos();
          this.contact();
        },
        render: function(){
          ctx.clearRect(0,0,canvas.width,canvas.height);
          this.blueSquare.render();
          this.greenSquare.render();
          //this.wall.render();
        },
        contact: function(){
          /*if(Math.abs(this.greenSquare.x-this.wall.x) <= (this.greenSquare.width+this.wall.width)/2){
            this.greenSquare.xSpeed = -this.greenSquare.xSpeed
          }
          if(Math.abs(this.blueSquare.x-this.wall.x) <= (this.blueSquare.width+this.wall.width)/2){
            this.blueSquare.xSpeed = -this.blueSquare.xSpeed
          }*/
          let bg = this.collision(this.blueSquare, this.greenSquare);
          let blueSpeed = Math.pow(this.blueSquare.xSpeed,2)+Math.pow(this.blueSquare.ySpeed,2);
          let greenSpeed = Math.pow(this.greenSquare.xSpeed,2)+Math.pow(this.greenSquare.ySpeed,2);
          if(bg[0]){
            this.blueSquare.xSpeed = blueSpeed*bg[1];
            this.greenSquare.xSpeed = greenSpeed*bg[1];
            this.blueSquare.ySpeed = blueSpeed*bg[2];
            this.greenSquare.ySpeed = greenSpeed*bg[2];
          }
          /*if(Math.abs(this.blueSquare.x-this.greenSquare.x) <= (this.blueSquare.hitBox+this.greenSquare.hitBox)){
            console.log(Math.abs(this.blueSquare.x-this.greenSquare.x));
            this.blueSquare.xSpeed = -this.blueSquare.xSpeed;
            this.greenSquare.xSpeed = -this.greenSquare.xSpeed;
          }*/
        },
        collision: function(a, b){
          let prop = [];
          if(Math.pow(a.x-b.x,2)+Math.pow(a.y-b.y,2) <= a.hitBox+b.hitBox){
            //If a.x-b.x > 0 a is left to b
            //If a.y-b.y > 0 a is down to b
            //a.x-b.x+a.y-b.y = tot => PropX : ax-bx/(a.x-b.x+a.y-b.y)
            let tot = a.x-b.x+a.y-b.y;
            prop = [true, a.x-b.x/tot, a.y-b.y/tot]

          } else{
            prop = [false];
          }
          return prop;
        }
      }
      function init(){
        canvas = document.getElementById('gameArea');
        ctx = canvas.getContext('2d');
        Game.then = performance.now();
        Game.blueSquare.xSpeed = 100;
        Game.blueSquare.ySpeed = -100;
        Game.greenSquare.xSpeed = -100;
        Game.greenSquare.ySpeed = -100;
        main();
      }
      function main() {
        window.requestAnimationFrame( main );
        //time at loop start
        Game.now = performance.now();
        Game.tSLF = (Game.now - Game.then)/1000;

        if(Game.tSLF > 16/1000){ //Aprox 60FPS
          //console.log(1/Game.tSLF);
          Game.update();
          Game.render();
          Game.then = Game.now;
        }
      }

    </script>
  </head>
  <body onload="init()">
    <canvas id="gameArea" height="800" width="1200"></canvas>
  </body>
</html>
